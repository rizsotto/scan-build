# -*- coding: utf-8 -*-
# SPDX-License-Identifier: MIT

import sys
import os
import os.path
import subprocess
import lit.util

this_dir = os.path.dirname(__file__)
tests_dir = os.path.dirname(this_dir)
project_dir = os.path.dirname(tests_dir)
tool_dir = os.path.join(this_dir, 'tools')

config.name = 'scan-build'

config.test_format = lit.formats.ShTest()
config.test_exec_root = this_dir
config.test_source_root = this_dir

config.suffixes = ['.ft', '.ftp']
config.excludes = []

config.substitutions.append(
    ('%{python}', sys.executable))


def is_available(program):
    try:
        subprocess.call([program, '--version'], stdout=subprocess.PIPE)
    except:
        return False
    else:
        return True

if is_available('coverage'):
    config.available_features.add('coverage')

if is_available('scons'):
    config.available_features.add('scons')

if is_available('qmake-qt4'):
    config.available_features.add('qmake')
    config.substitutions.append(('%{qmake}', 'qmake-qt4'))
elif is_available('qmake-qt5'):
    config.available_features.add('qmake')
    config.substitutions.append(('%{qmake}', 'qmake-qt5'))
elif is_available('qmake'):
    config.available_features.add('qmake')
    config.substitutions.append(('%{qmake}', 'qmake'))

if is_available('make'):
    config.available_features.add('make')
    config.substitutions.append(('%{make}', 'make'))
elif is_available('mingw32-make'):
    config.available_features.add('make')
    config.substitutions.append(('%{make}', 'mingw32-make'))


# classify os script language
is_windows = sys.platform in {'win32', 'cygwin'}
if is_windows:
    config.available_features.add('batch')
    config.suffixes.append('.bat')
    config.environment['windows'] = 'True'
else:
    config.available_features.add('shell')
    config.suffixes.append('.fts')


# functional test configuration
config.environment['test_input_dir'] = os.path.join(this_dir, 'Input')

config.environment['CC'] = 'clang'
config.environment['CXX'] = 'clang++'

ab = 'analyze-build'
sb = 'scan-build'
ib = 'intercept-build'

# use binaries from $PATH or bin_dir (does not require package install).
if lit_config.params.get('USE_INSTALLED') is None:
    bin_dir = os.path.join(this_dir, 'bin')

    config.environment['PATH'] = os.pathsep.join([bin_dir, os.environ['PATH']])
    config.environment['PYTHONPATH'] = project_dir

# run with coverage if the tool is available
if 'coverage' in config.available_features:
    rc_file = os.path.join(project_dir, '.coveragerc')
    config.environment['COVERAGE_PROCESS_START'] = rc_file

    coverage = 'coverage run --rcfile={rc}'.format(rc=rc_file)
    ab = '{coverage} {path}'.format(
        coverage=coverage,
        path=os.path.join(bin_dir, 'analyze-build'))
    sb = '{coverage} {path}'.format(
        coverage=coverage,
        path=os.path.join(bin_dir, 'scan-build'))
    ib = '{coverage} {path}'.format(
        coverage=coverage,
        path=os.path.join(bin_dir, 'intercept-build'))

config.substitutions.append(
    ('%{analyze-build}',
     '{cmd} -vvvv'.format(cmd=ab)))
config.substitutions.append(
    ('%{scan-build}',
     '{cmd} -vvvv'.format(cmd=sb)))
config.substitutions.append(
    ('%{intercept-build}',
     '{cmd} -vvvv'.format(cmd=ib)))
config.substitutions.append(
    ('%{cdb_diff}',
    '{python} {diff}'.format(python=sys.executable, diff=os.path.join(tool_dir, 'diff.py'))))
config.substitutions.append(
    ('%{expect}',
    '{python} {expect}'.format(python=sys.executable, expect=os.path.join(tool_dir, 'expect.py'))))


print("lit.cfg config")
print(config.substitutions)
print(config.environment)
print(config.available_features)
